{"title":"Poisson Regression Examples","markdown":{"yaml":{"title":"Poisson Regression Examples","author":"Komal Nagaraj Kattigenahally","date":"today","callout-appearance":"minimal"},"headingText":"Blueprinty Case Study","containsRefs":false,"markdown":"\n\n\n\n### Introduction\n\nBlueprinty is a small firm that makes software for developing blueprints specifically for submitting patent applications to the US patent office. Their marketing team would like to make the claim that patent applicants using Blueprinty's software are more successful in getting their patent applications approved. Ideal data to study such an effect might include the success rate of patent applications before using Blueprinty's software and after using it. Unfortunately, such data is not available. \n\nHowever, Blueprinty has collected data on 1,500 mature (non-startup) engineering firms. The data include each firm's number of patents awarded over the last 5 years, regional location, age since incorporation, and whether or not the firm uses Blueprinty's software. The marketing team would like to use this data to make the claim that firms using Blueprinty's software are more successful in getting their patent applications approved.\n\n\n### Data\n\n\nLet's read the data for Blueprinty's\n```{python}\nimport pandas as pd \nimport matplotlib.pyplot as plt\n\nblueprint = pd.read_csv('blueprinty.csv')\nblueprint.head()\n```\n\n\n```{python}\nmean_iscust = blueprint[blueprint['iscustomer'] == 1]['patents'].mean()\nmean_isnot_cust = blueprint[blueprint['iscustomer'] == 0]['patents'].mean()\nprint(\"Mean number of patents for Blueprinty's customers: \", round(mean_iscust, 3))\nprint(\"Mean number of patents of non-Blueprinty's customers: \", round(mean_isnot_cust, 2))\n\n# Histogram of number of patents for Blueprinty customers\nplt.figure(figsize=(8, 5))\nplt.hist(blueprint[blueprint['iscustomer'] == 1]['patents'], bins=20, color='blue', alpha=0.7)\nplt.xlabel('Number of Patents')\nplt.ylabel('Frequency')\nplt.title('Histogram of Patents - Blueprint Customers')\nplt.grid(True)\nplt.show()\n\n# Histogram of number of patents for non-customers\nplt.figure(figsize=(8, 5))\nplt.hist(blueprint[blueprint['iscustomer'] == 0]['patents'], bins=20, color='orange', alpha=0.7)\nplt.xlabel('Number of Patents')\nplt.ylabel('Frequency')\nplt.title(\"Histogram of Patents - Non-Customers\")\nplt.grid(True)\nplt.show()\n```\n\nFrom the above histograms of number of patents by customer status it is observed that, for non customers the highest number of patents are around 2-3 and for Blueprinty's customers it is around 4-5. The mean number of patents for Blueprinty's customers is 4.133 and for non customters it is 3.47.\nA larger proportion of Blueprinty's customers have large number of patents (8-16) as compared to that of non-customers.\n\nBlueprinty customers are not selected at random. It may be important to account for systematic differences in the age and regional location of customers vs non-customers.\n\nLet's vizualize the age distribution of customers vs non-customers\n```{python}\n\n# Plot for customers\nplt.figure(figsize=(8, 5))\nplt.hist(blueprint[blueprint['iscustomer'] == 1]['age'], bins=20, color='purple', alpha=0.7)\nplt.xlabel('Age')\nplt.ylabel('Frequency')\nplt.title('Age Distribution - Customers')\nplt.grid(True)\nplt.show()\n\n# Plot for non-customers\nplt.figure(figsize=(8, 5))\nplt.hist(blueprint[blueprint['iscustomer'] == 0]['age'], bins=20, color='skyblue', alpha=0.7)\nplt.xlabel('Age')\nplt.ylabel('Frequency')\nplt.title('Age Distribution - Non-Customers')\nplt.grid(True)\nplt.show()\n```\n\n\nFrom the above age distributions of Blueprinty's current customers it is seen that - \n\n- The distribution is spread out, but heavily skewed toward younger ages (18–30)\n- Due to its concentration in younger age group this suggests Blueprint is more attractive to younger individuals or startups.\n\nThe non-customer age distribution suggests the following - \n\n- It is more concentrated, suggesting a larger and more consistent population.\n- The age range is broader and more evenly distributed. This suggests the non-customer segment includes more mature, possibly more established individuals or companies.\n\nLet's visualize the distribution by region for customers vs non-customers\n```{python}\n# Visualize regional distribution by customer status\n\n# Histogram for customers\nplt.figure(figsize=(8, 5))\ncustomer_regions = blueprint[blueprint['iscustomer'] == 1]['region']\nplt.hist(customer_regions, bins=20, color='violet', alpha=0.7)\nplt.xlabel('Region')\nplt.ylabel('Frequency')\nplt.title('Regional Distribution - Customers')\nplt.grid(True)\nplt.show()\n\n# Histogram for non-customers\nplt.figure(figsize=(8, 5))\nnon_customer_regions = blueprint[blueprint['iscustomer'] == 0]['region']\nplt.hist(non_customer_regions, bins=20, color='lightgreen', alpha=0.7)\nplt.xlabel('Region')\nplt.ylabel('Frequency')\nplt.title('Regional Distribution - Non-Customers')\nplt.grid(True)\nplt.show()\n```\n\nFor the Customers of Blueprinty:\n\n- Northeast has the largest number of customers  — over 300 customers.\n- All other regions (Southwest, Midwest, South, Northwest) have much smaller numbers — around 30–50 each.\n- This suggests Blueprint is very strong in the Northeast and underrepresented elsewhere.\n\nFor Non-Customers:\n- The distribution is much more balanced distribution across all regions.\n- Northeast, Southwest, Midwest lead, each with ~250–270.\n- Northwest and South are slightly lower, but still significant (~150+).\n\n\n### Estimation of Simple Poisson Model\n\nSince our outcome variable of interest can only be small integer values per a set unit of time, we can use a Poisson density to model the number of patents awarded to each engineering firm over the last 5 years. We start by estimating a simple Poisson model via Maximum Likelihood.\n\nMathematically the likelihood for_ $Y \\sim \\text{Poisson}(\\lambda)$\n\nThe likelihood function for the entire sample is:\n\n$$\n\\mathcal{L}(\\lambda) = \\prod_{i=1}^{n} \\frac{e^{-\\lambda} \\lambda^{Y_i}}{Y_i!}\n$$\n\nAnd the log-likelihood function is:\n\n$$\n\\log \\mathcal{L}(\\lambda) = -n\\lambda + \\left( \\sum_{i=1}^{n} Y_i \\right) \\log \\lambda - \\sum_{i=1}^{n} \\log Y_i!\n$$\n\nNow we will use Python to estimate the log likelihood function. Code below :\n\n```{python}\nimport numpy as np\nfrom math import factorial\n\n# Poisson likelihood function\n# Log-likelihood function\ndef poisson_loglikelihood(lmbda, Y):\n    if lmbda <= 0:\n        return -np.inf  # avoid log(0)\n    return -len(Y)*lmbda + np.sum(Y)*np.log(lmbda) - np.sum(np.log([factorial(y) for y in Y]))\n\n```\n\nNext, we will plot the Poisson Log-Likelihood vs Lambda. This plot visualizes how the Poisson log-likelihood function changes as we vary the rate parameter λ (lambda) — which represents the expected count of patents.\nSome points to note in the plot - \n\n- When λ is too low or too high, the log-likelihood drops, meaning those values poorly explain the data.\n\n- The maximum point on the curve gives the λ that best fits the data — this is the MLE, and is often equal to the sample mean in a simple Poisson model.\n\n- The curve helps us visualize parameter uncertainty: a flatter curve means more uncertainty in the estimate; a steeper curve means the estimate is more precise.\n\n```{python}\nY = blueprint['patents']\nlambda_vals = np.linspace(0.1, 10, 100)\nloglik_vals = [poisson_loglikelihood(lmbda, Y) for lmbda in lambda_vals]\n\n# Find MLE\nmle_lambda = lambda_vals[np.argmax(loglik_vals)]\n\n# Plot\nplt.figure(figsize=(8, 5))\nplt.plot(lambda_vals, loglik_vals, label=\"Log-Likelihood\", color='blue')\nplt.axvline(x=mle_lambda, color='red', linestyle='--', label=f'MLE = {mle_lambda:.2f}')\nplt.xlabel(\"Lambda (λ)\")\nplt.ylabel(\"Log-Likelihood\")\nplt.title(\"Poisson Log-Likelihood vs. Lambda\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n```\n\nNow, we will estimate the MLE by making use of the first derivative of log-likelhood function. We will do this with Python :\n\n```{python}\ndef poisson_loglikelihood_derivative(lmbda, Y):\n    if lmbda <= 0:\n        return np.nan  # avoid division by zero\n    n = len(Y)\n    sum_Y = np.sum(Y)\n    return -n + (sum_Y / lmbda)\n\n# Plot log-likelihood and its derivative\nlambda_vals = np.linspace(0.1, 10, 100)\nloglik_vals = [poisson_loglikelihood(lmbda, Y) for lmbda in lambda_vals]\nderivative_vals = [poisson_loglikelihood_derivative(lmbda, Y) for lmbda in lambda_vals]\n\n# Find MLE\nmle_lambda = lambda_vals[np.argmax(loglik_vals)]\n\n\n# Plot derivative\nplt.plot(lambda_vals, derivative_vals, label=\"First Derivative\", color='green')\nplt.axhline(y=0, color='black', linestyle='--')\nplt.axvline(x=mle_lambda, color='red', linestyle='--', label=\"Zero Crossing (MLE)\")\nplt.xlabel(\"Lambda (λ)\")\nplt.ylabel(\"Derivative\")\nplt.title(\"First Derivative of Log-Likelihood\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n```\nFurther, we will estimate the MLE by optimizing the likelihood function with sp.optimize() in Python\n\n```{python}\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom math import factorial, log\n\n# Sample observed data\nY = blueprint['patents']\n\n# Define the negative log-likelihood function\ndef neg_log_likelihood(lmbda_array):\n    lmbda = lmbda_array[0]\n    if lmbda <= 0:\n        return np.inf  # avoid invalid values\n    n = len(Y)\n    sum_Y = sum(Y)\n    const_term = sum([log(factorial(y)) for y in Y])  # optional\n    return -(-n * lmbda + sum_Y * log(lmbda) - const_term)\n\n# Initial guess\ninitial_lambda = [1.0]\n\n# Minimize\nresult = minimize(neg_log_likelihood, initial_lambda, method='L-BFGS-B', bounds=[(0.0001, None)])\n\n# Extract MLE\nlambda_mle = result.x[0]\nprint(f\"MLE for λ using minimize(): {lambda_mle:.4f}\")\n\n```\n\n\nThree approaches are used to find the MLE value. the results from all three approaches are as follows :\n\n1. Grid Search and Plotting:\nThe log-likelihood is computed over a grid of λ values and plotted them. The maximum occurred at approximatel 3.68.\n\n2. First Derivative :\nThe first derivate is taken and plotted. The derivative crossed zero at the approximately same λ, confirming the MLE analytically.\n\nNumerical Optimization:\nUsing scipy.optimize.minimize(), we minimized the negative log-likelihood and MLE obtained is 3.6847\n\nThis matched our previous results closely, validating both the numerical and analytical solutions.\n\n### Estimation of Poisson Regression Model\n\nNext, we extend our simple Poisson model to a Poisson Regression Model such that $Y_i = \\text{Poisson}(\\lambda_i)$ where $\\lambda_i = \\exp(X_i'\\beta)$. The interpretation is that the success rate of patent awards is not constant across all firms ($\\lambda$) but rather is a function of firm characteristics $X_i$. Specifically, we will use the covariates age, age squared, region, and whether the firm is a customer of Blueprinty.\n\n```{python}\n\nimport numpy as np\n\n# Poisson log-likelihood for regression model\ndef poisson_log_likelihood(beta, X, Y):\n    X = np.asarray(X)\n    Y = np.asarray(Y)\n    beta = np.asarray(beta)\n\n    # Linear predictor: Xβ\n    eta = X @ beta\n\n    # Inverse link function: λ = exp(η)\n    lam = np.exp(eta)\n\n    # Log-likelihood\n    loglik = np.sum(Y * np.log(lam) - lam - np.log([np.math.factorial(int(y)) for y in Y]))\n\n    return -loglik  # negative for use with minimize()\n```\n\nNow we use Python's sp.optimze() to find the MLE vector and the Hessian of the Poisson model with covariates. \n\n```{python}\n\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import minimize\nfrom numpy.linalg import inv\nfrom scipy.special import gammaln\n\n# ---- Feature Engineering ----\nblueprint['age_sq'] = blueprint['age'] ** 2\nregion_dummies = pd.get_dummies(blueprint['region'], drop_first=True)\n\n# ---- Design Matrix X ----\nX = pd.concat([\n    pd.Series(1, index=blueprint.index, name='Intercept'),\n    blueprint[['age', 'age_sq', 'iscustomer']],\n    region_dummies\n], axis=1)\nX_matrix =  X.astype(float).values\n\n# ---- Outcome Variable Y ----\nY = blueprint['patents'].values\n\n# ---- Poisson Log-Likelihood Function ----\ndef poisson_log_likelihood(beta, X, Y):\n    Xb = X @ beta\n    Xb = np.clip(Xb, -20, 20)  # safe range for exp\n    lam = np.exp(Xb)\n    loglik = np.sum(Y * np.log(lam) - lam - gammaln(Y + 1))\n    return -loglik  # negative for minimization\n\n# ---- Estimation ----\nbeta_init = np.zeros(X_matrix.shape[1])\nresult = minimize(poisson_log_likelihood, beta_init, args=(X_matrix, Y), method='BFGS')\n\n# ---- Extract Coefficients and Standard Errors ----\nbeta_hat = result.x\nhessian_inv = result.hess_inv\nstd_errors = np.sqrt(np.diag(hessian_inv))\n\n# ---- Results Table ----\nresults_df = pd.DataFrame({\n    'Coefficient': beta_hat,\n    'Std. Error': std_errors\n}, index=X.columns)\n\nprint(results_df.round(4))\n\n```\n\n\nChecking for similar results using Python's sm.GLM() below:\n\n```{python}\nimport statsmodels.api as sm\n\n# Make sure X and Y are both purely numeric\nX_numeric = X.astype(float)\nY_numeric = pd.Series(Y).astype(float)\n\n# Fit GLM model\nmodel = sm.GLM(Y_numeric, X_numeric, family=sm.families.Poisson())\nresults = model.fit()\n\n# Print the results\nprint(results.summary())\n\n```\n\n**Interpretation** \n\nWe estimated a Poisson regression model to examine the relationship between firm characteristics and the number of patents awarded. The following interpretations can be made based on the results obatined -\n\n- Age: The coefficient for age is positive and statistically significant (p < 0.001), while the coefficient for age_sq is negative and also highly significant. This suggests a nonlinear relationship between firm age and patenting activity. Specifically, patenting increases with age up to a point, then begins to decline — forming an inverted-U relationship\n\n- Customer Status: The variable iscustomer has a positive and significant coefficient (p < 0.001), indicating that firms who are Blueprinty customers file approximately 23% more patents than non-customers, all else equal. This highlights a potential link between Blueprint's services and increased innovation outcomes.\n\n- Region: Coefficients for regional indicators (Northeast, Northwest, South, Southwest) are not statistically significant at the 5% level. This implies that, after controlling for age and customer status, regional differences in patenting are minimal or not detectable in this sample. \n\n- The pseudo R-squared is 0.136, indicating a modest but meaningful improvement over a null model.\n\nNow we estimate the number of patents for customers vs non-customers using the following mthods : We create X_0 and X_1 where X_0 is the X data but with iscustomer=0 for every observation and X_1 is the X data but with iscustomer=1 for every observation. Then, use X_0 and the fitted model to get the vector of predicted number of patents (y_pred_0) for every firm in the dataset, and use X_1 to get Y_pred_1 for every firm. Then subtract y_pred_1 minus y_pred_0 and take the average of that vector of differences.\n\n```{python}\nimport numpy as np\n\n# Create two counterfactual datasets:\n# X_0: everyone is NOT a customer (iscustomer = 0)\n# X_1: everyone IS a customer (iscustomer = 1)\n\nX_0 = X.copy()\nX_1 = X.copy()\n\nX_0['iscustomer'] = 0\nX_1['iscustomer'] = 1\n\n# Convert to matrix form\nX_0_matrix = X_0.astype(float).values\nX_1_matrix = X_1.astype(float).values\n\n# Predicted number of patents using fitted model\nXb_0 = np.clip(X_0_matrix @ beta_hat, -20, 20)\nXb_1 = np.clip(X_1_matrix @ beta_hat, -20, 20)\n\ny_pred_0 = np.exp(Xb_0)\ny_pred_1 = np.exp(Xb_1)\n\n# Difference in predicted patent counts\ndelta = y_pred_1 - y_pred_0\naverage_diff = np.mean(delta)\n\nprint(\"Average difference in number of patents for customers vs non customers:\" , round(average_diff,3))\n\n```\nThe above results imply that Firms using Blueprinty's software are predicted to produce, on average, 0.79 more patents than they would have without it - all else held constant.\n\n## AirBnB Case Study\n\n### Introduction\n\nAirBnB is a popular platform for booking short-term rentals. In March 2017, students Annika Awad, Evan Lebo, and Anna Linden scraped of 40,000 Airbnb listings from New York City.  The data include the following variables:\n\n:::: {.callout-note collapse=\"true\"}\n### Variable Definitions\n\n    - `id` = unique ID number for each unit\n    - `last_scraped` = date when information scraped\n    - `host_since` = date when host first listed the unit on Airbnb\n    - `days` = `last_scraped` - `host_since` = number of days the unit has been listed\n    - `room_type` = Entire home/apt., Private room, or Shared room\n    - `bathrooms` = number of bathrooms\n    - `bedrooms` = number of bedrooms\n    - `price` = price per night (dollars)\n    - `number_of_reviews` = number of reviews for the unit on Airbnb\n    - `review_scores_cleanliness` = a cleanliness score from reviews (1-10)\n    - `review_scores_location` = a \"quality of location\" score from reviews (1-10)\n    - `review_scores_value` = a \"quality of value\" score from reviews (1-10)\n    - `instant_bookable` = \"t\" if instantly bookable, \"f\" if not\n\n::::\n\n\n\n```{python}\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\n\n# Load the Airbnb data (change path if needed)\nairbnb = pd.read_csv(\"airbnb.csv\")\n\n# --- Clean and prepare data ---\nairbnb_clean = airbnb[[\n    'room_type', 'bathrooms', 'bedrooms', 'price', 'number_of_reviews',\n    'review_scores_cleanliness', 'review_scores_location',\n    'review_scores_value', 'instant_bookable'\n]].copy()\n\n# Convert price to float\nairbnb_clean['price'] = (\n    airbnb_clean['price'].replace('[\\$,]', '', regex=True).astype(float)\n)\n\n# Drop rows with missing values\nairbnb_clean.dropna(inplace=True)\n\n# Convert categorical variables to dummy variables\nairbnb_encoded = pd.get_dummies(\n    airbnb_clean,\n    columns=['room_type', 'instant_bookable'],\n    drop_first=True  # avoids dummy variable trap\n)\n\n# --- Set up model inputs ---\nX = sm.add_constant(X)\nX = X.astype(float)\nY = Y.astype(float) \n\npoisson_model = sm.GLM(Y, X, family=sm.families.Poisson())\n\nresults = poisson_model.fit()\n\n# --- Print model results ---\nsummary_df = pd.DataFrame({\n    'Coefficient': results.params,\n    'Std. Error': results.bse,\n    'z-value': results.tvalues,\n    'p-value': results.pvalues\n}).round(4)\n\nprint(summary_df)\n\n\n\n```\n\nEstimating the same model with glm below :\n\n```{python}\npoisson_model = sm.GLM(Y, X, family=sm.families.Poisson())\nresults = poisson_model.fit()\nprint(results.summary())\n\n```\n\nWe estimated a Poisson regression model to understand which listing characteristics predict the number of Airbnb reviews, used here as a proxy for bookings. Several variables emerged as significant predictors:\n\n- Instant bookable status had the strongest effect: listings that allow instant booking received ~40% (exp(0.334))  more reviews, highlighting the importance of booking convenience.\n\n- Cleanliness score was another strong predictor: a 1-point increase in cleanliness rating corresponded to a ~12% (exp(0.113)) increase in reviews.\n\n- Bedrooms were positively associated with reviews — each additional bedroom was linked to an ~8% increase in expected bookings.\n\n- In contrast, shared rooms received ~22% fewer reviews than entire homes/apartments, and private rooms had a slight negative effect as well.\n\n- Bathrooms, review_scores_location, and review_scores_value showed negative associations with review count, suggesting that certain amenities or subjective perceptions may not directly translate to more bookings.\n\n- These results emphasize the importance of user experience factors (cleanliness, ease of booking) and listing type in attracting more guests.\n\n- Pseudo R squared = 0.5649, or ~56% This means the model explains about 56% of the variation in the number of reviews relative to a null model\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n\n## Blueprinty Case Study\n\n### Introduction\n\nBlueprinty is a small firm that makes software for developing blueprints specifically for submitting patent applications to the US patent office. Their marketing team would like to make the claim that patent applicants using Blueprinty's software are more successful in getting their patent applications approved. Ideal data to study such an effect might include the success rate of patent applications before using Blueprinty's software and after using it. Unfortunately, such data is not available. \n\nHowever, Blueprinty has collected data on 1,500 mature (non-startup) engineering firms. The data include each firm's number of patents awarded over the last 5 years, regional location, age since incorporation, and whether or not the firm uses Blueprinty's software. The marketing team would like to use this data to make the claim that firms using Blueprinty's software are more successful in getting their patent applications approved.\n\n\n### Data\n\n\nLet's read the data for Blueprinty's\n```{python}\nimport pandas as pd \nimport matplotlib.pyplot as plt\n\nblueprint = pd.read_csv('blueprinty.csv')\nblueprint.head()\n```\n\n\n```{python}\nmean_iscust = blueprint[blueprint['iscustomer'] == 1]['patents'].mean()\nmean_isnot_cust = blueprint[blueprint['iscustomer'] == 0]['patents'].mean()\nprint(\"Mean number of patents for Blueprinty's customers: \", round(mean_iscust, 3))\nprint(\"Mean number of patents of non-Blueprinty's customers: \", round(mean_isnot_cust, 2))\n\n# Histogram of number of patents for Blueprinty customers\nplt.figure(figsize=(8, 5))\nplt.hist(blueprint[blueprint['iscustomer'] == 1]['patents'], bins=20, color='blue', alpha=0.7)\nplt.xlabel('Number of Patents')\nplt.ylabel('Frequency')\nplt.title('Histogram of Patents - Blueprint Customers')\nplt.grid(True)\nplt.show()\n\n# Histogram of number of patents for non-customers\nplt.figure(figsize=(8, 5))\nplt.hist(blueprint[blueprint['iscustomer'] == 0]['patents'], bins=20, color='orange', alpha=0.7)\nplt.xlabel('Number of Patents')\nplt.ylabel('Frequency')\nplt.title(\"Histogram of Patents - Non-Customers\")\nplt.grid(True)\nplt.show()\n```\n\nFrom the above histograms of number of patents by customer status it is observed that, for non customers the highest number of patents are around 2-3 and for Blueprinty's customers it is around 4-5. The mean number of patents for Blueprinty's customers is 4.133 and for non customters it is 3.47.\nA larger proportion of Blueprinty's customers have large number of patents (8-16) as compared to that of non-customers.\n\nBlueprinty customers are not selected at random. It may be important to account for systematic differences in the age and regional location of customers vs non-customers.\n\nLet's vizualize the age distribution of customers vs non-customers\n```{python}\n\n# Plot for customers\nplt.figure(figsize=(8, 5))\nplt.hist(blueprint[blueprint['iscustomer'] == 1]['age'], bins=20, color='purple', alpha=0.7)\nplt.xlabel('Age')\nplt.ylabel('Frequency')\nplt.title('Age Distribution - Customers')\nplt.grid(True)\nplt.show()\n\n# Plot for non-customers\nplt.figure(figsize=(8, 5))\nplt.hist(blueprint[blueprint['iscustomer'] == 0]['age'], bins=20, color='skyblue', alpha=0.7)\nplt.xlabel('Age')\nplt.ylabel('Frequency')\nplt.title('Age Distribution - Non-Customers')\nplt.grid(True)\nplt.show()\n```\n\n\nFrom the above age distributions of Blueprinty's current customers it is seen that - \n\n- The distribution is spread out, but heavily skewed toward younger ages (18–30)\n- Due to its concentration in younger age group this suggests Blueprint is more attractive to younger individuals or startups.\n\nThe non-customer age distribution suggests the following - \n\n- It is more concentrated, suggesting a larger and more consistent population.\n- The age range is broader and more evenly distributed. This suggests the non-customer segment includes more mature, possibly more established individuals or companies.\n\nLet's visualize the distribution by region for customers vs non-customers\n```{python}\n# Visualize regional distribution by customer status\n\n# Histogram for customers\nplt.figure(figsize=(8, 5))\ncustomer_regions = blueprint[blueprint['iscustomer'] == 1]['region']\nplt.hist(customer_regions, bins=20, color='violet', alpha=0.7)\nplt.xlabel('Region')\nplt.ylabel('Frequency')\nplt.title('Regional Distribution - Customers')\nplt.grid(True)\nplt.show()\n\n# Histogram for non-customers\nplt.figure(figsize=(8, 5))\nnon_customer_regions = blueprint[blueprint['iscustomer'] == 0]['region']\nplt.hist(non_customer_regions, bins=20, color='lightgreen', alpha=0.7)\nplt.xlabel('Region')\nplt.ylabel('Frequency')\nplt.title('Regional Distribution - Non-Customers')\nplt.grid(True)\nplt.show()\n```\n\nFor the Customers of Blueprinty:\n\n- Northeast has the largest number of customers  — over 300 customers.\n- All other regions (Southwest, Midwest, South, Northwest) have much smaller numbers — around 30–50 each.\n- This suggests Blueprint is very strong in the Northeast and underrepresented elsewhere.\n\nFor Non-Customers:\n- The distribution is much more balanced distribution across all regions.\n- Northeast, Southwest, Midwest lead, each with ~250–270.\n- Northwest and South are slightly lower, but still significant (~150+).\n\n\n### Estimation of Simple Poisson Model\n\nSince our outcome variable of interest can only be small integer values per a set unit of time, we can use a Poisson density to model the number of patents awarded to each engineering firm over the last 5 years. We start by estimating a simple Poisson model via Maximum Likelihood.\n\nMathematically the likelihood for_ $Y \\sim \\text{Poisson}(\\lambda)$\n\nThe likelihood function for the entire sample is:\n\n$$\n\\mathcal{L}(\\lambda) = \\prod_{i=1}^{n} \\frac{e^{-\\lambda} \\lambda^{Y_i}}{Y_i!}\n$$\n\nAnd the log-likelihood function is:\n\n$$\n\\log \\mathcal{L}(\\lambda) = -n\\lambda + \\left( \\sum_{i=1}^{n} Y_i \\right) \\log \\lambda - \\sum_{i=1}^{n} \\log Y_i!\n$$\n\nNow we will use Python to estimate the log likelihood function. Code below :\n\n```{python}\nimport numpy as np\nfrom math import factorial\n\n# Poisson likelihood function\n# Log-likelihood function\ndef poisson_loglikelihood(lmbda, Y):\n    if lmbda <= 0:\n        return -np.inf  # avoid log(0)\n    return -len(Y)*lmbda + np.sum(Y)*np.log(lmbda) - np.sum(np.log([factorial(y) for y in Y]))\n\n```\n\nNext, we will plot the Poisson Log-Likelihood vs Lambda. This plot visualizes how the Poisson log-likelihood function changes as we vary the rate parameter λ (lambda) — which represents the expected count of patents.\nSome points to note in the plot - \n\n- When λ is too low or too high, the log-likelihood drops, meaning those values poorly explain the data.\n\n- The maximum point on the curve gives the λ that best fits the data — this is the MLE, and is often equal to the sample mean in a simple Poisson model.\n\n- The curve helps us visualize parameter uncertainty: a flatter curve means more uncertainty in the estimate; a steeper curve means the estimate is more precise.\n\n```{python}\nY = blueprint['patents']\nlambda_vals = np.linspace(0.1, 10, 100)\nloglik_vals = [poisson_loglikelihood(lmbda, Y) for lmbda in lambda_vals]\n\n# Find MLE\nmle_lambda = lambda_vals[np.argmax(loglik_vals)]\n\n# Plot\nplt.figure(figsize=(8, 5))\nplt.plot(lambda_vals, loglik_vals, label=\"Log-Likelihood\", color='blue')\nplt.axvline(x=mle_lambda, color='red', linestyle='--', label=f'MLE = {mle_lambda:.2f}')\nplt.xlabel(\"Lambda (λ)\")\nplt.ylabel(\"Log-Likelihood\")\nplt.title(\"Poisson Log-Likelihood vs. Lambda\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n```\n\nNow, we will estimate the MLE by making use of the first derivative of log-likelhood function. We will do this with Python :\n\n```{python}\ndef poisson_loglikelihood_derivative(lmbda, Y):\n    if lmbda <= 0:\n        return np.nan  # avoid division by zero\n    n = len(Y)\n    sum_Y = np.sum(Y)\n    return -n + (sum_Y / lmbda)\n\n# Plot log-likelihood and its derivative\nlambda_vals = np.linspace(0.1, 10, 100)\nloglik_vals = [poisson_loglikelihood(lmbda, Y) for lmbda in lambda_vals]\nderivative_vals = [poisson_loglikelihood_derivative(lmbda, Y) for lmbda in lambda_vals]\n\n# Find MLE\nmle_lambda = lambda_vals[np.argmax(loglik_vals)]\n\n\n# Plot derivative\nplt.plot(lambda_vals, derivative_vals, label=\"First Derivative\", color='green')\nplt.axhline(y=0, color='black', linestyle='--')\nplt.axvline(x=mle_lambda, color='red', linestyle='--', label=\"Zero Crossing (MLE)\")\nplt.xlabel(\"Lambda (λ)\")\nplt.ylabel(\"Derivative\")\nplt.title(\"First Derivative of Log-Likelihood\")\nplt.legend()\nplt.grid(True)\nplt.tight_layout()\nplt.show()\n\n```\nFurther, we will estimate the MLE by optimizing the likelihood function with sp.optimize() in Python\n\n```{python}\n\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom math import factorial, log\n\n# Sample observed data\nY = blueprint['patents']\n\n# Define the negative log-likelihood function\ndef neg_log_likelihood(lmbda_array):\n    lmbda = lmbda_array[0]\n    if lmbda <= 0:\n        return np.inf  # avoid invalid values\n    n = len(Y)\n    sum_Y = sum(Y)\n    const_term = sum([log(factorial(y)) for y in Y])  # optional\n    return -(-n * lmbda + sum_Y * log(lmbda) - const_term)\n\n# Initial guess\ninitial_lambda = [1.0]\n\n# Minimize\nresult = minimize(neg_log_likelihood, initial_lambda, method='L-BFGS-B', bounds=[(0.0001, None)])\n\n# Extract MLE\nlambda_mle = result.x[0]\nprint(f\"MLE for λ using minimize(): {lambda_mle:.4f}\")\n\n```\n\n\nThree approaches are used to find the MLE value. the results from all three approaches are as follows :\n\n1. Grid Search and Plotting:\nThe log-likelihood is computed over a grid of λ values and plotted them. The maximum occurred at approximatel 3.68.\n\n2. First Derivative :\nThe first derivate is taken and plotted. The derivative crossed zero at the approximately same λ, confirming the MLE analytically.\n\nNumerical Optimization:\nUsing scipy.optimize.minimize(), we minimized the negative log-likelihood and MLE obtained is 3.6847\n\nThis matched our previous results closely, validating both the numerical and analytical solutions.\n\n### Estimation of Poisson Regression Model\n\nNext, we extend our simple Poisson model to a Poisson Regression Model such that $Y_i = \\text{Poisson}(\\lambda_i)$ where $\\lambda_i = \\exp(X_i'\\beta)$. The interpretation is that the success rate of patent awards is not constant across all firms ($\\lambda$) but rather is a function of firm characteristics $X_i$. Specifically, we will use the covariates age, age squared, region, and whether the firm is a customer of Blueprinty.\n\n```{python}\n\nimport numpy as np\n\n# Poisson log-likelihood for regression model\ndef poisson_log_likelihood(beta, X, Y):\n    X = np.asarray(X)\n    Y = np.asarray(Y)\n    beta = np.asarray(beta)\n\n    # Linear predictor: Xβ\n    eta = X @ beta\n\n    # Inverse link function: λ = exp(η)\n    lam = np.exp(eta)\n\n    # Log-likelihood\n    loglik = np.sum(Y * np.log(lam) - lam - np.log([np.math.factorial(int(y)) for y in Y]))\n\n    return -loglik  # negative for use with minimize()\n```\n\nNow we use Python's sp.optimze() to find the MLE vector and the Hessian of the Poisson model with covariates. \n\n```{python}\n\nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import minimize\nfrom numpy.linalg import inv\nfrom scipy.special import gammaln\n\n# ---- Feature Engineering ----\nblueprint['age_sq'] = blueprint['age'] ** 2\nregion_dummies = pd.get_dummies(blueprint['region'], drop_first=True)\n\n# ---- Design Matrix X ----\nX = pd.concat([\n    pd.Series(1, index=blueprint.index, name='Intercept'),\n    blueprint[['age', 'age_sq', 'iscustomer']],\n    region_dummies\n], axis=1)\nX_matrix =  X.astype(float).values\n\n# ---- Outcome Variable Y ----\nY = blueprint['patents'].values\n\n# ---- Poisson Log-Likelihood Function ----\ndef poisson_log_likelihood(beta, X, Y):\n    Xb = X @ beta\n    Xb = np.clip(Xb, -20, 20)  # safe range for exp\n    lam = np.exp(Xb)\n    loglik = np.sum(Y * np.log(lam) - lam - gammaln(Y + 1))\n    return -loglik  # negative for minimization\n\n# ---- Estimation ----\nbeta_init = np.zeros(X_matrix.shape[1])\nresult = minimize(poisson_log_likelihood, beta_init, args=(X_matrix, Y), method='BFGS')\n\n# ---- Extract Coefficients and Standard Errors ----\nbeta_hat = result.x\nhessian_inv = result.hess_inv\nstd_errors = np.sqrt(np.diag(hessian_inv))\n\n# ---- Results Table ----\nresults_df = pd.DataFrame({\n    'Coefficient': beta_hat,\n    'Std. Error': std_errors\n}, index=X.columns)\n\nprint(results_df.round(4))\n\n```\n\n\nChecking for similar results using Python's sm.GLM() below:\n\n```{python}\nimport statsmodels.api as sm\n\n# Make sure X and Y are both purely numeric\nX_numeric = X.astype(float)\nY_numeric = pd.Series(Y).astype(float)\n\n# Fit GLM model\nmodel = sm.GLM(Y_numeric, X_numeric, family=sm.families.Poisson())\nresults = model.fit()\n\n# Print the results\nprint(results.summary())\n\n```\n\n**Interpretation** \n\nWe estimated a Poisson regression model to examine the relationship between firm characteristics and the number of patents awarded. The following interpretations can be made based on the results obatined -\n\n- Age: The coefficient for age is positive and statistically significant (p < 0.001), while the coefficient for age_sq is negative and also highly significant. This suggests a nonlinear relationship between firm age and patenting activity. Specifically, patenting increases with age up to a point, then begins to decline — forming an inverted-U relationship\n\n- Customer Status: The variable iscustomer has a positive and significant coefficient (p < 0.001), indicating that firms who are Blueprinty customers file approximately 23% more patents than non-customers, all else equal. This highlights a potential link between Blueprint's services and increased innovation outcomes.\n\n- Region: Coefficients for regional indicators (Northeast, Northwest, South, Southwest) are not statistically significant at the 5% level. This implies that, after controlling for age and customer status, regional differences in patenting are minimal or not detectable in this sample. \n\n- The pseudo R-squared is 0.136, indicating a modest but meaningful improvement over a null model.\n\nNow we estimate the number of patents for customers vs non-customers using the following mthods : We create X_0 and X_1 where X_0 is the X data but with iscustomer=0 for every observation and X_1 is the X data but with iscustomer=1 for every observation. Then, use X_0 and the fitted model to get the vector of predicted number of patents (y_pred_0) for every firm in the dataset, and use X_1 to get Y_pred_1 for every firm. Then subtract y_pred_1 minus y_pred_0 and take the average of that vector of differences.\n\n```{python}\nimport numpy as np\n\n# Create two counterfactual datasets:\n# X_0: everyone is NOT a customer (iscustomer = 0)\n# X_1: everyone IS a customer (iscustomer = 1)\n\nX_0 = X.copy()\nX_1 = X.copy()\n\nX_0['iscustomer'] = 0\nX_1['iscustomer'] = 1\n\n# Convert to matrix form\nX_0_matrix = X_0.astype(float).values\nX_1_matrix = X_1.astype(float).values\n\n# Predicted number of patents using fitted model\nXb_0 = np.clip(X_0_matrix @ beta_hat, -20, 20)\nXb_1 = np.clip(X_1_matrix @ beta_hat, -20, 20)\n\ny_pred_0 = np.exp(Xb_0)\ny_pred_1 = np.exp(Xb_1)\n\n# Difference in predicted patent counts\ndelta = y_pred_1 - y_pred_0\naverage_diff = np.mean(delta)\n\nprint(\"Average difference in number of patents for customers vs non customers:\" , round(average_diff,3))\n\n```\nThe above results imply that Firms using Blueprinty's software are predicted to produce, on average, 0.79 more patents than they would have without it - all else held constant.\n\n## AirBnB Case Study\n\n### Introduction\n\nAirBnB is a popular platform for booking short-term rentals. In March 2017, students Annika Awad, Evan Lebo, and Anna Linden scraped of 40,000 Airbnb listings from New York City.  The data include the following variables:\n\n:::: {.callout-note collapse=\"true\"}\n### Variable Definitions\n\n    - `id` = unique ID number for each unit\n    - `last_scraped` = date when information scraped\n    - `host_since` = date when host first listed the unit on Airbnb\n    - `days` = `last_scraped` - `host_since` = number of days the unit has been listed\n    - `room_type` = Entire home/apt., Private room, or Shared room\n    - `bathrooms` = number of bathrooms\n    - `bedrooms` = number of bedrooms\n    - `price` = price per night (dollars)\n    - `number_of_reviews` = number of reviews for the unit on Airbnb\n    - `review_scores_cleanliness` = a cleanliness score from reviews (1-10)\n    - `review_scores_location` = a \"quality of location\" score from reviews (1-10)\n    - `review_scores_value` = a \"quality of value\" score from reviews (1-10)\n    - `instant_bookable` = \"t\" if instantly bookable, \"f\" if not\n\n::::\n\n\n\n```{python}\nimport pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\n\n# Load the Airbnb data (change path if needed)\nairbnb = pd.read_csv(\"airbnb.csv\")\n\n# --- Clean and prepare data ---\nairbnb_clean = airbnb[[\n    'room_type', 'bathrooms', 'bedrooms', 'price', 'number_of_reviews',\n    'review_scores_cleanliness', 'review_scores_location',\n    'review_scores_value', 'instant_bookable'\n]].copy()\n\n# Convert price to float\nairbnb_clean['price'] = (\n    airbnb_clean['price'].replace('[\\$,]', '', regex=True).astype(float)\n)\n\n# Drop rows with missing values\nairbnb_clean.dropna(inplace=True)\n\n# Convert categorical variables to dummy variables\nairbnb_encoded = pd.get_dummies(\n    airbnb_clean,\n    columns=['room_type', 'instant_bookable'],\n    drop_first=True  # avoids dummy variable trap\n)\n\n# --- Set up model inputs ---\nX = sm.add_constant(X)\nX = X.astype(float)\nY = Y.astype(float) \n\npoisson_model = sm.GLM(Y, X, family=sm.families.Poisson())\n\nresults = poisson_model.fit()\n\n# --- Print model results ---\nsummary_df = pd.DataFrame({\n    'Coefficient': results.params,\n    'Std. Error': results.bse,\n    'z-value': results.tvalues,\n    'p-value': results.pvalues\n}).round(4)\n\nprint(summary_df)\n\n\n\n```\n\nEstimating the same model with glm below :\n\n```{python}\npoisson_model = sm.GLM(Y, X, family=sm.families.Poisson())\nresults = poisson_model.fit()\nprint(results.summary())\n\n```\n\nWe estimated a Poisson regression model to understand which listing characteristics predict the number of Airbnb reviews, used here as a proxy for bookings. Several variables emerged as significant predictors:\n\n- Instant bookable status had the strongest effect: listings that allow instant booking received ~40% (exp(0.334))  more reviews, highlighting the importance of booking convenience.\n\n- Cleanliness score was another strong predictor: a 1-point increase in cleanliness rating corresponded to a ~12% (exp(0.113)) increase in reviews.\n\n- Bedrooms were positively associated with reviews — each additional bedroom was linked to an ~8% increase in expected bookings.\n\n- In contrast, shared rooms received ~22% fewer reviews than entire homes/apartments, and private rooms had a slight negative effect as well.\n\n- Bathrooms, review_scores_location, and review_scores_value showed negative associations with review count, suggesting that certain amenities or subjective perceptions may not directly translate to more bookings.\n\n- These results emphasize the importance of user experience factors (cleanliness, ease of booking) and listing type in attracting more guests.\n\n- Pseudo R squared = 0.5649, or ~56% This means the model explains about 56% of the variation in the number of reviews relative to a null model\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"hw2_questions.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","theme":"cosmo","title":"Poisson Regression Examples","author":"Komal Nagaraj Kattigenahally","date":"today","callout-appearance":"minimal"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}