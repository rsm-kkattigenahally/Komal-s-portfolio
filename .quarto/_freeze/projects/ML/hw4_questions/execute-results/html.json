{
  "hash": "f266ee9056b3c5f8ba6d68c7c8478e3e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Latent class MNL and KNN\"\nauthor: \"Komal Kattigenahally\"\ndate: today\njupyter: python3\n---\n\n\n\n\n## Latent-Class MNL\n\nIn this project, we will create a latent class MNL for a Yogurt purchase data. \nThe Latent Class Multinomial Logit (LC-MNL) model is an extension of the standard Multinomial Logit (MNL) model that captures unobserved heterogeneity in individual decision-making. While the MNL model assumes all individuals share the same preferences, the LC-MNL model allows for the population to consist of several latent (hidden) segments or classes, each with distinct choice behaviors.\n\n### Utility Specification\n\nLet the utility that individual $n$ obtains from choosing alternative $j$ in class $s$ be:\n\n$$\nU_{nj}^{(s)} = X_{nj}'\\beta_s + \\varepsilon_{nj}\n$$\n\nWhere:\n\n- $X_{nj}$ is the vector of observed attributes of the alternative  \n- $\\beta_s$ is the class-specific coefficient vector  \n- $\\varepsilon_{nj}$ is a random error term  \n\nThe probability that an individual belongs to class $s$ is denoted $\\pi_s$, such that:\n\n$$\n\\sum_{s=1}^{S} \\pi_s = 1\n$$\n\nThe choice probability for individual $n$ choosing alternative $j$, marginalizing over classes, is:\n\n$$\nP_{nj} = \\sum_{s=1}^{S} \\pi_s \\cdot \\frac{\\exp(X_{nj}'\\beta_s)}{\\sum_{k=1}^{J} \\exp(X_{nk}'\\beta_s)}\n$$\n\n\nIn the standard Multinomial Logit (MNL) model, Alternative-Specific Constants (ASCs) are included to account for the inherent preference for each product that is not explained by observable attributes such as price or featured status. These constants capture baseline utility differences between alternatives.\n\nMathematically, the utility of individual $n$ choosing alternative $j$ can be written as:\n\n$$\nU_{nj} = ASC_j + \\beta_1 \\cdot \\text{price}_{nj} + \\beta_2 \\cdot \\text{featured}_{nj} + \\varepsilon_{nj}\n$$\n\n\nWhere $ASC_j$ is the alternative-specific constant for product $j$. One of the ASCs (typically for the base category) is omitted to avoid perfect multicollinearity. The remaining ASCs indicate how much more or less preferred each alternative is compared to the base product, holding all else equal.\n\n#### Yogurt latent class MNL\nIn the Yogurt dataset that we have, anonymized consumer identifiers (`id`), a vector indicating the chosen product (`y1`:`y4`), a vector indicating if any products were \"featured\" in the store as a form of advertising (`f1`:`f4`), and the products' prices in price-per-ounce (`p1`:`p4`). For example, consumer 1 purchased yogurt 4 at a price of 0.079/oz and none of the yogurts were featured/advertised at the time of consumer 1's purchase.\n\nData preview - \n\n::: {#6d570bd3 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\n\nyogurt_data = pd.read_csv('yogurt_data.csv')\nyogurt_data.head(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>y1</th>\n      <th>y2</th>\n      <th>y3</th>\n      <th>y4</th>\n      <th>f1</th>\n      <th>f2</th>\n      <th>f3</th>\n      <th>f4</th>\n      <th>p1</th>\n      <th>p2</th>\n      <th>p3</th>\n      <th>p4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n      <td>0.081</td>\n      <td>0.061</td>\n      <td>0.079</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n      <td>0.098</td>\n      <td>0.064</td>\n      <td>0.075</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n      <td>0.098</td>\n      <td>0.061</td>\n      <td>0.086</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n      <td>0.098</td>\n      <td>0.061</td>\n      <td>0.086</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.125</td>\n      <td>0.098</td>\n      <td>0.049</td>\n      <td>0.079</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>6</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n      <td>0.092</td>\n      <td>0.050</td>\n      <td>0.079</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>7</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.103</td>\n      <td>0.081</td>\n      <td>0.049</td>\n      <td>0.079</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>8</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n      <td>0.086</td>\n      <td>0.054</td>\n      <td>0.079</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>9</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n      <td>0.098</td>\n      <td>0.050</td>\n      <td>0.079</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>10</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n      <td>0.098</td>\n      <td>0.050</td>\n      <td>0.079</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe will first reshape this dataset from wide to long format\n\n::: {#1e6d533f .cell execution_count=2}\n``` {.python .cell-code}\n## Reshape dataset \nyogurt_data = pd.wide_to_long(yogurt_data,\n                          stubnames=['y', 'f', 'p'],\n                          i='id',\n                          j='product',\n                          sep='',\n                          suffix='[1-4]').reset_index()\n\n# Rename columns for clarity\nyogurt_data = yogurt_data.rename(columns={\n    'y': 'chosen',\n    'f': 'featured',\n    'p': 'price'\n})\nyogurt_data.head(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>product</th>\n      <th>chosen</th>\n      <th>featured</th>\n      <th>price</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>4</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>5</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.125</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>6</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>7</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.103</td>\n    </tr>\n    <tr>\n      <th>7</th>\n      <td>8</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0</td>\n      <td>0.108</td>\n    </tr>\n    <tr>\n      <th>8</th>\n      <td>9</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0.108</td>\n    </tr>\n    <tr>\n      <th>9</th>\n      <td>10</td>\n      <td>1</td>\n      <td>1</td>\n      <td>0</td>\n      <td>0.108</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nIn the above reshaped data, each row represents a consumer–product combination with with data about if the product was chosen by the consumer, if the product was featured abd the price per ounce for that product.\n\n\n### Standard MNL on Yogurt data\nHere we will fit a standard MNL model on the reshaped dataset. When fitting the MNL model in Python using libraries like statsmodels, the ASCs are not automatically created from a categorical variable like product. Therefore, we manually create dummy variables for alternatives using one-hot encoding. The process are as follows - \n\n1. One-hot encode the product variable: This converts the product IDs into binary variables. We drop one column (e.g., for product 1) to act as the reference category.\n\nThese dummy variables become our ASCs. They allow the model to capture each product's inherent preference or appeal that isn't explained by price or promotion. Without ASCs, the model would wrongly assume all products are equally preferred when price and promotion are the same.\n\n2. Merge dummies into the dataset: After encoding, we merge these dummy columns with the dataset so that they can be used as predictors in the model.\n\nBelow we see the code to carry out the above steps.\n\n::: {#f27470a7 .cell execution_count=3}\n``` {.python .cell-code}\nimport statsmodels.api as sm\nfrom sklearn.preprocessing import OneHotEncoder\n\nencoder = OneHotEncoder(drop='first', sparse_output=False)\nproduct_dummies = encoder.fit_transform(yogurt_data[['product']])\n\n# Create DataFrame with appropriate column names\nproduct_dummies_df = pd.DataFrame(product_dummies, columns=encoder.get_feature_names_out())\n\n# Merge dummies with main data\nyogurt_data = pd.concat([yogurt_data.reset_index(drop=True), product_dummies_df.reset_index(drop=True)], axis=1)\nproduct_dummies_df\n\n# Define independent variables (price, featured, and ASCs)\nX = yogurt_data[['price', 'featured'] + list(product_dummies_df.columns)]\nX = sm.add_constant(X)  # Add intercept\nX\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>const</th>\n      <th>price</th>\n      <th>featured</th>\n      <th>product_2</th>\n      <th>product_3</th>\n      <th>product_4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1.0</td>\n      <td>0.108</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1.0</td>\n      <td>0.108</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1.0</td>\n      <td>0.108</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>1.0</td>\n      <td>0.108</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>1.0</td>\n      <td>0.125</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>9715</th>\n      <td>1.0</td>\n      <td>0.086</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>9716</th>\n      <td>1.0</td>\n      <td>0.086</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>9717</th>\n      <td>1.0</td>\n      <td>0.086</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>9718</th>\n      <td>1.0</td>\n      <td>0.086</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n    <tr>\n      <th>9719</th>\n      <td>1.0</td>\n      <td>0.079</td>\n      <td>0</td>\n      <td>0.0</td>\n      <td>0.0</td>\n      <td>1.0</td>\n    </tr>\n  </tbody>\n</table>\n<p>9720 rows × 6 columns</p>\n</div>\n```\n:::\n:::\n\n\nThe independent variables for the model includes:\n\n- price: price per ounce\n\n- featured: whether the product was promoted\n\n- product_2, product_3, product_4: dummy variables representing ASCs for products 2, 3, and 4 (product 1 is the reference)\n\n::: {#59da231f .cell execution_count=4}\n``` {.python .cell-code}\n# Dependent variable: whether the product was chosen (1 if chosen, 0 otherwise)\ny = yogurt_data['chosen']\ny\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n0       0\n1       0\n2       0\n3       0\n4       0\n       ..\n9715    1\n9716    1\n9717    1\n9718    1\n9719    1\nName: chosen, Length: 9720, dtype: int64\n```\n:::\n:::\n\n\nThe above data is our dependent variable.\n\n::: {#d1ca7461 .cell execution_count=5}\n``` {.python .cell-code}\n# Fit the Multinomial Logit model\nmodel = sm.MNLogit(y, X)\nresult = model.fit()\n\n# Show model summary\nresult.summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOptimization terminated successfully.\n         Current function value: 0.477971\n         Iterations 7\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<table class=\"simpletable\">\n<caption>MNLogit Regression Results</caption>\n<tr>\n  <th>Dep. Variable:</th>        <td>chosen</td>      <th>  No. Observations:  </th>  <td>  9720</td> \n</tr>\n<tr>\n  <th>Model:</th>                <td>MNLogit</td>     <th>  Df Residuals:      </th>  <td>  9714</td> \n</tr>\n<tr>\n  <th>Method:</th>                 <td>MLE</td>       <th>  Df Model:          </th>  <td>     5</td> \n</tr>\n<tr>\n  <th>Date:</th>            <td>Wed, 11 Jun 2025</td> <th>  Pseudo R-squ.:     </th>  <td>0.1500</td> \n</tr>\n<tr>\n  <th>Time:</th>                <td>23:30:49</td>     <th>  Log-Likelihood:    </th> <td> -4645.9</td>\n</tr>\n<tr>\n  <th>converged:</th>             <td>True</td>       <th>  LL-Null:           </th> <td> -5465.9</td>\n</tr>\n<tr>\n  <th>Covariance Type:</th>     <td>nonrobust</td>    <th>  LLR p-value:       </th>  <td> 0.000</td> \n</tr>\n</table>\n<table class=\"simpletable\">\n<tr>\n  <th>chosen=1</th>     <th>coef</th>     <th>std err</th>      <th>z</th>      <th>P>|z|</th>  <th>[0.025</th>    <th>0.975]</th>  \n</tr>\n<tr>\n  <th>const</th>     <td>    2.7009</td> <td>    0.229</td> <td>   11.795</td> <td> 0.000</td> <td>    2.252</td> <td>    3.150</td>\n</tr>\n<tr>\n  <th>price</th>     <td>  -31.9761</td> <td>    2.089</td> <td>  -15.305</td> <td> 0.000</td> <td>  -36.071</td> <td>  -27.881</td>\n</tr>\n<tr>\n  <th>featured</th>  <td>    0.4714</td> <td>    0.119</td> <td>    3.959</td> <td> 0.000</td> <td>    0.238</td> <td>    0.705</td>\n</tr>\n<tr>\n  <th>product_2</th> <td>   -0.5166</td> <td>    0.081</td> <td>   -6.354</td> <td> 0.000</td> <td>   -0.676</td> <td>   -0.357</td>\n</tr>\n<tr>\n  <th>product_3</th> <td>   -4.5584</td> <td>    0.173</td> <td>  -26.319</td> <td> 0.000</td> <td>   -4.898</td> <td>   -4.219</td>\n</tr>\n<tr>\n  <th>product_4</th> <td>   -1.4179</td> <td>    0.089</td> <td>  -16.008</td> <td> 0.000</td> <td>   -1.591</td> <td>   -1.244</td>\n</tr>\n</table>\n```\n:::\n:::\n\n\nFrom the above summary we see, that\n\n- Price has a very strong negative effect on the choice. Even a small increase in price substantially  reduced the choice probability.\n\n- Featured promotions positively impact the consumer decision. This effect is small.\n\n- Product 1 is the most preferred product and Product 2 is least preferred.\n\n### Latent class MNL model on Yogurt dataset\nNext, we will fit a Latent-class MNL on the same data.\n\n::: {#34bd36e4 .cell execution_count=6}\n``` {.python .cell-code}\nimport numpy as np\nimport biogeme.database as db\nimport biogeme.biogeme as bio\nfrom biogeme.expressions import Beta, log, exp\nfrom biogeme import models\n\ndef lc_mnl(K, df):\n    database = db.Database(\"yogurt\", df)\n    database.variables['Choice'] = df['chosen']\n    av = {1: 1, 2: 1, 3: 1, 4: 1}\n\n    class_utilities = []\n    membership_betas = []\n\n    for k in range(1, K + 1):\n        ASC2 = Beta(f'ASC2_class{k}', 0, None, None, 0)\n        ASC3 = Beta(f'ASC3_class{k}', 0, None, None, 0)\n        ASC4 = Beta(f'ASC4_class{k}', 0, None, None, 0)\n        B_PRICE = Beta(f'B_PRICE_class{k}', 0, None, None, 0)\n        B_FEAT = Beta(f'B_FEAT_class{k}', 0, None, None, 0)\n\n        V = {\n            1: 0,\n            2: ASC2 + B_PRICE * database.variables['price'] + B_FEAT * database.variables['featured'],\n            3: ASC3 + B_PRICE * database.variables['price'] + B_FEAT * database.variables['featured'],\n            4: ASC4 + B_PRICE * database.variables['price'] + B_FEAT * database.variables['featured']\n        }\n\n        logprob = models.loglogit(V, av, database.variables['product'])\n        class_utilities.append(logprob)\n\n        if k < K:\n            pi_k = Beta(f'PI_{k}', 1.0 / K, 0.0001, 0.9999, 0)\n            membership_betas.append(pi_k)\n\n    if K == 2:\n        PI = [membership_betas[0], 1 - membership_betas[0]]\n    else:\n        exp_terms = [exp(beta) for beta in membership_betas]\n        denominator = sum(exp_terms) + 1\n        PI = [term / denominator for term in exp_terms]\n        PI.append(1 - sum(PI))\n\n    loglikelihood = log(sum([PI[k] * exp(class_utilities[k]) for k in range(K)]))\n    biogeme_model = bio.BIOGEME(database, loglikelihood)\n    biogeme_model.modelName = f\"LC_MNL_{K}classes\"\n    results = biogeme_model.estimate()\n\n    return {\n        \"K\": K,\n        \"LogLikelihood\": results.data.logLike,\n        \"NumParams\": results.data.nparam,\n        \"BIC\": -2 * results.data.logLike + results.data.nparam * np.log(df['id'].nunique()),\n        \"Parameters\": results.get_estimated_parameters()\n    }\n\n```\n:::\n\n\nTo determine the optimal number of latent classes, we estimate LC-MNL models for 2, 3, 4, and 5 classes and compare them using the Bayesian Information Criterion (BIC) given by :\n\n$BIC = -2*\\ell_n  + k*log(n)$? \n\n(where $\\ell_n$ is the log-likelihood, $n$ is the sample size, and $k$ is the number of parameters.) \n\nBIC is a widely used tool for comparing models in terms of both their fit and parsimony. Unlike the raw log-likelihood, which only measures how well a model explains the data, the BIC includes a penalty for model complexity—specifically, the number of estimated parameters. This ensures that adding more classes (which almost always improves fit) is only favored if the improvement is substantial enough to justify the added complexity.\n\nIn the context of the LC-MNL model, BIC allows us to determine the optimal number of latent classes. Each additional class introduces its own set of parameters (utility coefficients and class probabilities), which can risk overfitting if not justified by significant gains in likelihood.\n\n::: {#0313b96c .cell execution_count=7}\n``` {.python .cell-code}\nresults_list = []\nfor K in range(2, 6):\n    print(f\"Estimating model for {K} classes...\")\n    res = lc_mnl(K, yogurt_data)\n    results_list.append(res)\n    #print(f\"Estimated parameters for K = {K}:\")\n    #print(res[\"Parameters\"])\n\nbic_df = pd.DataFrame(results_list).sort_values(by='BIC')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEstimating model for 2 classes...\nEstimating model for 3 classes...\nEstimating model for 4 classes...\nEstimating model for 5 classes...\n```\n:::\n:::\n\n\n::: {#79faadae .cell execution_count=8}\n``` {.python .cell-code}\nbic_df[['K', 'LogLikelihood', 'NumParams', 'BIC']]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>K</th>\n      <th>LogLikelihood</th>\n      <th>NumParams</th>\n      <th>BIC</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>1</th>\n      <td>3</td>\n      <td>-8987.653693</td>\n      <td>17</td>\n      <td>18107.833378</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>5</td>\n      <td>-9270.488187</td>\n      <td>29</td>\n      <td>18767.050124</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>4</td>\n      <td>-9533.099772</td>\n      <td>23</td>\n      <td>19245.499414</td>\n    </tr>\n    <tr>\n      <th>0</th>\n      <td>2</td>\n      <td>-10505.854498</td>\n      <td>11</td>\n      <td>21097.461107</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe model with the lowest BIC is selected as the best-fitting model when balancing accuracy and simplicity. In our results, the 3-class model had the lowest BIC, suggesting that it best explains the data while avoiding unnecessary complexity.\n\n#### Comparison of Aggregate MNL vs. Latent-Class MNL (K = 3)\n\nNow we compare the parameter estimates between (1) the aggregate MNL, and (2) the latent-class MNL with the number of classes suggested by the BIC.\n\n::: {#d6a9809c .cell execution_count=9}\n``` {.python .cell-code}\nlc_mnl_3class_params = results_list[[res[\"K\"] for res in results_list].index(3)][\"Parameters\"].reset_index()\nlc_mnl_3class_params.columns\nclass3_params = lc_mnl_3class_params.loc[lc_mnl_3class_params['index'].str.contains('_class3')]\nprint(\"Class 3 parameter estimates\")\nprint(class3_params)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClass 3 parameter estimates\n             index        Value  Active bound  Rob. Std err  Rob. t-test  \\\n2      ASC2_class3  -605.010055           0.0     33.700522   -17.952543   \n5      ASC3_class3  -609.283694           0.0     33.717245   -18.070388   \n8      ASC4_class3  -604.219992           0.0     33.709284   -17.924438   \n11   B_FEAT_class3  -613.933324           0.0     33.234146   -18.472968   \n14  B_PRICE_class3  9678.824025           0.0    535.352517    18.079347   \n\n    Rob. p-value  \n2            0.0  \n5            0.0  \n8            0.0  \n11           0.0  \n14           0.0  \n```\n:::\n:::\n\n\n#### 1. Price Sensitivity\n\n| Model            | Price Coefficient        | Interpretation                                                |\n|------------------|--------------------------|----------------------------------------------------------------|\n| Aggregate MNL    | –31.98 (significant)     | Consumers are price-sensitive overall.                         |\n| LC-MNL Class 1   | –3317.95 (not significant) | Very large, likely unstable estimate.                          |\n| LC-MNL Class 2   | –2799.99 (**significant**) | Very strong price aversion.                                    |\n| LC-MNL Class 3   | +9678.82 (**significant**) | Counterintuitive: price increases utility (possible overfitting or perceived quality). |\n\n---\n\n#### 2. Featured Promotion\n\n| Model            | Featured Coefficient      | Interpretation                                               |\n|------------------|---------------------------|---------------------------------------------------------------|\n| Aggregate MNL    | +0.471 (significant)       | Promotion increases likelihood of choice.                    |\n| LC-MNL Class 1   | +13.75 (significant)       | Strong positive impact of being featured.                    |\n| LC-MNL Class 2   | +19.73 (significant)       | Even stronger promotional effect.                            |\n| LC-MNL Class 3   | –613.93 (significant)      | Strong negative effect — promotions deter choice.            |\n\n---\n\n#### 3. Alternative-Specific Constants (ASCs)\n\n| Product | Aggregate MNL | LC Class 1 | LC Class 2 | LC Class 3 |\n|---------|----------------|------------|------------|------------|\n| ASC2    | –0.5166         | –1.02       | +280.04     | –605.01     |\n| ASC3    | –4.5584         | +222.88     | +0.86       | –609.28     |\n| ASC4    | –1.4179         | –2.92       | +279.78     | –604.22     |\n\nInterpretation:\n- LC-MNL reveals stark contrasts between classes.\n- Class 2 prefers all products highly.\n- Class 3 strongly disfavors all alternatives — unusual, possibly unstable.\n\n---\n\n#### 4. Class Membership Probabilities\n\n| Class    | Share (PI) | Interpretation                                       |\n|----------|------------|------------------------------------------------------|\n| Class 1  | 0.730       | Majority: strong effects for price and promotion.   |\n| Class 2  | 0.999       | Possibly absorbing similar behavior as Class 1.     |\n| Class 3  | ~0          | Tiny segment with extreme (and conflicting) effects.|\n\n---\n\n#### **Conclusion**\n\nThe aggregate MNL provides a stable average picture of consumer behavior: moderate price sensitivity and positive reaction to promotions.\n\nHowever, the 3-class LC-MNL uncovers **rich heterogeneity**:\n- **Class 1** behaves similarly to the aggregate trend.\n- **Class 2** intensifies the promotional impact.\n- **Class 3** behaves unusually, disliking promotions and favoring higher prices — likely capturing edge cases or requiring more robust modeling.\n\nLatent class modeling yields **deeper behavioral insights** that would be hidden in an aggregate approach — but demands careful interpretation, especially for small or extreme segments.\n\n\n## K Nearest Neighbors\n\n### How KNN Works\nGiven a data point $x_{\\text{test}}$ to classify:\n\n1. Compute the **distance** between $x_{\\text{test}}$ and all training points $x_i$.\n2. Identify the $k$ closest training points (called the **k-nearest neighbors**).\n3. Assign the **majority class** label among those $k$ neighbors to $x_{\\text{test}}$.\n\n---\n\n### Euclidean Distance\n\nThe most commonly used distance metric is the **Euclidean distance**, defined for two points \n$x = (x_1, x_2, \\dots, x_d)$ and $z = (z_1, z_2, \\dots, z_d)$ as:\n\n$$\nd(x, z) = \\sqrt{(x_1 - z_1)^2 + (x_2 - z_2)^2 + \\cdots + (x_d - z_d)^2}\n$$\n\nFor our 2D case with features $x_1$ and $x_2$:\n\n$$\nd((x_1, x_2), (z_1, z_2)) = \\sqrt{(x_1 - z_1)^2 + (x_2 - z_2)^2}\n$$\n\n---\n\n### Classification Rule\n\nLet $\\mathcal{N}_k(x)$ denote the set of indices of the $k$ nearest neighbors of point $x$.  \nThen the predicted class $\\hat{y}$ is:\n\n$$\n\\hat{y} = \\arg\\max_{c \\in \\{0,1\\}} \\sum_{i \\in \\mathcal{N}_k(x)} \\mathbb{1}(y_i = c)\n$$\n\nWhere:\n- $\\mathbb{1}(y_i = c)$ is an indicator function (1 if true, 0 if false),\n- This counts how many of the $k$ neighbors belong to class $c$,\n- The class with the highest count becomes the predicted class.\n\n---\n\n### Choosing the Right k\n\n- Small $k$ values (like $k=1$) can be sensitive to noise and may overfit.\n- Larger $k$ values smooth out the decision boundary but may underfit.\n- The optimal $k$ is usually chosen using validation data or cross-validation.\n\n---\n\n\nIn this section, we will explore how the K Nearest Neighbors (KNN) algorithm works using a synthetic dataset. We will implement KNN from scratch, compare it with a built-in classifier, and analyze how the value of k impacts model accuracy.\n\n### Generate Synthetic Data\nThe following code will generate a synthetic dataset for the k-nearest neighbors algorithm.  The code generates a dataset with two features, `x1` and `x2`, and a binary outcome variable `y` that is determined by whether `x2` is above or below a wiggly boundary defined by a sin function\n\n::: {#0bffde48 .cell execution_count=10}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# Generate data\nnp.random.seed(42)\nn = 100\nx1 = np.random.uniform(-3, 3, n)\nx2 = np.random.uniform(-3, 3, n)\n\nboundary = np.sin(4 * x1) + x1\ny = (x2 > boundary).astype(int)\n\ndf = pd.DataFrame({'x1': x1, 'x2': x2, 'y': y})\ndf\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x1</th>\n      <th>x2</th>\n      <th>y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-0.752759</td>\n      <td>-2.811425</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2.704286</td>\n      <td>0.818462</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>1.391964</td>\n      <td>-1.113864</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>0.591951</td>\n      <td>0.051424</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>-2.063888</td>\n      <td>2.445399</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>95</th>\n      <td>-0.037226</td>\n      <td>-0.904743</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>96</th>\n      <td>0.136397</td>\n      <td>1.355734</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>97</th>\n      <td>-0.434754</td>\n      <td>2.382662</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>98</th>\n      <td>-2.847485</td>\n      <td>2.322519</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>99</th>\n      <td>-2.352651</td>\n      <td>1.679253</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n<p>100 rows × 3 columns</p>\n</div>\n```\n:::\n:::\n\n\nWe can visualize the dataset in 2D, using color to represent the binary class (y). We also overlay the wiggly boundary that separates the two classes.\n\n::: {#83d18698 .cell execution_count=11}\n``` {.python .cell-code}\nplt.figure(figsize=(8,6))\nplt.scatter(df['x1'], df['x2'], c=df['y'], cmap='bwr', edgecolor='k')\nx_line = np.linspace(-3, 3, 500)\nboundary_line = np.sin(4 * x_line) + x_line\nplt.plot(x_line, boundary_line, 'k--', label='Boundary')\nplt.xlabel('x1')\nplt.ylabel('x2')\nplt.title('Synthetic Dataset')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](hw4_questions_files/figure-html/cell-12-output-1.png){width=662 height=523}\n:::\n:::\n\n\nTo evaluate the generalization performance of our model, we create a new test dataset using a different random seed. This ensures the test data is independent of the training set.\n\n::: {#01a83e01 .cell execution_count=12}\n``` {.python .cell-code}\nnp.random.seed(19)  # different seed\nx1_test = np.random.uniform(-3, 3, n)\nx2_test = np.random.uniform(-3, 3, n)\nboundary_test = np.sin(4 * x1_test) + x1_test\ny_test = (x2_test > boundary_test).astype(int)\n\ntest_df = pd.DataFrame({'x1': x1_test, 'x2': x2_test, 'y': y_test})\ntest_df\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>x1</th>\n      <th>x2</th>\n      <th>y</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>-2.414798</td>\n      <td>1.925009</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1.567498</td>\n      <td>1.899944</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>-1.518372</td>\n      <td>-1.001426</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>-2.171210</td>\n      <td>1.053791</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>-1.011321</td>\n      <td>2.900615</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>95</th>\n      <td>-1.764803</td>\n      <td>-2.503910</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>96</th>\n      <td>-1.274871</td>\n      <td>-1.705154</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>97</th>\n      <td>-0.711182</td>\n      <td>1.546217</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>98</th>\n      <td>2.011124</td>\n      <td>-1.815811</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>99</th>\n      <td>-2.507545</td>\n      <td>-0.332287</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n<p>100 rows × 3 columns</p>\n</div>\n```\n:::\n:::\n\n\n### KNN implementation by hand Vs KNeighborsClassifier\nHere we define a custom KNN classifier using the Euclidean distance between test and training points. For each test instance, the k closest neighbors are selected, and the predicted class is determined by majority vote.\n\n::: {#2c943936 .cell execution_count=13}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.spatial import distance\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import accuracy_score\n\ndef knn_predict(X_train, y_train, X_test, k):\n    y_pred = []\n    for test_point in X_test:\n        dists = [distance.euclidean(test_point, train_point) for train_point in X_train]\n        knn_indices = np.argsort(dists)[:k]\n        knn_labels = y_train[knn_indices]\n        # Use np.bincount safely: labels must be integers starting from 0\n        # If labels are 0 and 1, this is fine\n        majority_vote = np.argmax(np.bincount(knn_labels))\n        y_pred.append(majority_vote)\n    return np.array(y_pred)\n\n# Prepare train and test datasets\nX_train = df[['x1', 'x2']].values\ny_train = df['y'].values.astype(int)  # convert to int\nX_test = test_df[['x1', 'x2']].values\ny_test = test_df['y'].values.astype(int)  # convert to int\n\n# Convert y arrays to numpy integer arrays if needed\ny_train = np.array(y_train).astype(int)\ny_test = np.array(y_test).astype(int)\n\n# Built-in KNN classifier\nclf = KNeighborsClassifier(n_neighbors=5)\nclf.fit(X_train, y_train)\ny_lib_pred = clf.predict(X_test)\n\n# Your manual KNN prediction\ny_hand_pred = knn_predict(X_train, y_train, X_test, k=5)\n\n# Compare predictions\nprint(\"Hand-coded KNN accuracy:\", accuracy_score(y_test, y_hand_pred))\nprint(\"Library KNN accuracy:   \", accuracy_score(y_test, y_lib_pred))\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHand-coded KNN accuracy: 0.87\nLibrary KNN accuracy:    0.87\n```\n:::\n:::\n\n\nNow we run our custom KNN function across a range of k values (from 1 to 30) to observe how accuracy varies. This helps us identify the optimal value of k that balances underfitting and overfitting.\n\n::: {#0bb18963 .cell execution_count=14}\n``` {.python .cell-code}\nfrom sklearn.metrics import accuracy_score\n\nX_train = df[['x1', 'x2']].values\ny_train = df['y'].values\nX_test = test_df[['x1', 'x2']].values\ny_test = test_df['y'].values\n\naccuracies = []\n\nfor k in range(1, 31):\n    y_pred = knn_predict(X_train, y_train, X_test, k)\n    acc = accuracy_score(y_test, y_pred)\n    accuracies.append(acc * 100)\n```\n:::\n\n\nWe plot the accuracy of the KNN model as a function of k to visualize the trend and identify the best k value.\n\n::: {#f34cb229 .cell execution_count=15}\n``` {.python .cell-code}\nplt.figure(figsize=(8,5))\nplt.plot(range(1, 31), accuracies, marker='o')\nplt.xlabel('k')\nplt.ylabel('Accuracy (%)')\nplt.title('KNN Accuracy on Test Data')\nplt.grid(True)\nplt.show()\n\noptimal_k = np.argmax(accuracies) + 1\nprint(f\"Optimal k: {optimal_k} with accuracy: {accuracies[optimal_k-1]:.2f}%\")\n```\n\n::: {.cell-output .cell-output-display}\n![](hw4_questions_files/figure-html/cell-16-output-1.png){width=659 height=449}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nOptimal k: 1 with accuracy: 92.00%\n```\n:::\n:::\n\n\n**Inference from the plot the accuracy of the KNN model as a function of k**\n\n- **Highest Accuracy at \\( k = 1 \\)** : The model achieves its **highest accuracy (~92%)** when \\( k = 1 \\).\n\n\n- **Sharp Drop from \\( k = 2 \\) to \\( k = 4 \\)** :  Accuracy declines quickly from ~90% to around 86–87% when \\( k \\) increases from 2 to 4.\n\n\n- **Fluctuations Between \\( k = 5 \\) and \\( k = 15 \\)** :  Accuracy fluctuates without a clear upward or downward trend. This suggests that the model struggles to capture a consistently optimal decision boundary in this range.\n\n\n- **Plateau After \\( k \\geq 15 \\)** : For values of \\( k \\geq 15 \\), accuracy stabilizes around **85–86%**. This trend reflects **underfitting**, where the model becomes too smooth and loses its ability to separate complex patterns in the data.\n\n\n- **Optimal Trade-off**:  While \\( k = 1 \\) yields the best test performance, using a slightly higher \\( k \\) (e.g., \\( k = 3 \\) or \\( k = 5 \\)) may provide a better **bias-variance trade-off**. This reduces the risk of overfitting while maintaining high accuracy.\n\n- **Summary :**\n\n- **Best test accuracy**: \\( k = 1 \\)\n- **Recommended practical range**: \\( k = 3 \\) to \\( k = 5 \\) for more robust results.\n\n",
    "supporting": [
      "hw4_questions_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}